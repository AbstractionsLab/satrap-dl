active: true
derived: false
header: |
  Transformer flow
level: 6
links:
- ARC-003: R0GD-wyqQaUFXEDlm6ChoGsrdZGrFgK3Vhcompn3I5g=
- ARC-004: wXgqP5HfGae4YvPa8H_8ak8vnLf6gWJpoRtmXjh2pps=
normative: true
ref: ''
reviewed: EC6TQ9OCcV2M05cNKgltmDlEHlPBxQkfNoVRjZJvC_8=
text: |
  ## Transformer sequence diagram

  The sequence diagram of the transformation process can be seen below:

  ![Transformer sequence diagram](assets/2C0A2F_DIA_Transformer-SeqDiagram.png "Transformer sequence diagram"){: width="80%"}

  Only function calls and interactions that are relevant to understand the information flow are shown. Especially interaction with plain data classes that are not used by the `STIXtoTypeQLTransformer` itself are left out, i.e. the creation of `Entity` or `Relation` objects that are inserted into `InsertQuery` objects which are again part of the `QueryBundle`. In addition, the `convert_to_typeql` functions differ a lot depending on the value type. For primitive data types, the functions indeed do not interact with other classes. However, for more complex data types, the `ValueConverter` interacts with the `STIXtoTypeDBMapper` to ask for information about the conversion steps and of course with the `Identity`, `Entity`, `Relation`, `InsertQuery` and therefore also with the `QueryBundle`.

  To provide an example, the sequence diagram for a function call of `convert_to_typeql` of a composite value can be seen below:

  ![Sequence diagram for the value conversion of a composite value](assets/2C0A2G_DIA_CompositeValue-SeqDiagram.png "Sequence diagram for the value conversion of a composite value"){: width="100%"}

  It can be seen that for every value in a composite value's properties, the ValueConverter is needed to convert the value. This is not shown in this sequence diagram as this sequence diagram already explains this step.
